macro_rules! help {
    ($args:expr) => {{
        println!("{} day part inputs\n\tday\t01..25\n\tpart = 1 or 2", $args[0]);
        println!("\tinputs: ");
        return
    }}
}
macro_rules! header {
    ($part:expr, $args:expr) => {
        println!("--- Day 5: Sunny with a Chance of Asteroids ---");
        println!("--- Part {}", $part);
        if $args.len() < 4 { help!($args); }
    };
}

macro_rules! read_3_params {
    ($inputs:expr, $addr:expr, $mode_a:expr, $mode_b:expr, $verbose:expr) => {{
        let addr_a = $inputs[$addr+1].clone();
        let addr_b = $inputs[$addr+2].clone();
        let addr_res = $inputs[$addr+3].clone();
        if $verbose { print!("[{},{},{},{}]\t", $inputs[$addr], addr_a, addr_b, addr_res); }
        let a;
        if $mode_a == 1 { a = addr_a; } else { a = $inputs[ addr_a as usize ]; }
        let b;
        if $mode_b == 1 { b = addr_b; } else { b = $inputs[ addr_b as usize ]; }
        (a, b, addr_res)
    }};
}
macro_rules! read_2_params {
    ($inputs:expr, $addr:expr, $mode_a:expr, $mode_b:expr, $verbose:expr) => {{
        let addr_a = $inputs[$addr+1].clone();
        let addr_b = $inputs[$addr+2].clone();
        if $verbose { print!("[{},{},{}]\t", $inputs[$addr], addr_a, addr_b); }
        let a;
        if $mode_a == 1 { a = addr_a; } else { a = $inputs[ addr_a as usize ]; }
        let b;
        if $mode_b == 1 { b = addr_b; } else { b = $inputs[ addr_b as usize ]; }
        (a, b)
    }};
}
macro_rules! read_1_param {
    ($inputs:expr, $addr:expr, $mode_a:expr, $verbose:expr) => {{
        let addr_a = $inputs[$addr+1].clone();
        if $verbose { print!("[{},{}]\t", $inputs[$addr], addr_a); }
        let a;
        if $mode_a == 1 { a = addr_a; } else { a = $inputs[ addr_a as usize ]; }
        (a)
    }};
}
macro_rules! write_1_param {
    ($inputs:expr, $addr:expr, $mode_a:expr, $value:expr, $verbose:expr) => {{
        let addr_a = $inputs[$addr+1].clone();
        if $verbose { print!("[{},{}]\t", $inputs[$addr], addr_a); }
        if $mode_a == 1 {
            $inputs[$addr+1] = $value;
        } else { 
            $inputs[ addr_a as usize ] = $value;
        }
    }};
}
fn run_program(mut inputs: Vec<i32>, input_val: i32, verbose: bool) -> i32 {
    let mut addr = 0;
    let mut output = -1;
    while inputs[addr] != 99 {
        let opcode = inputs[addr] % 100;
        let mode_a = inputs[addr]/100 % 10;
        let mode_b = inputs[addr]/1000 % 10;
        let result;
        if  opcode == 1  {
            let (a, b, addr_res) = read_3_params!(inputs, addr, mode_a, mode_b, verbose);
            if verbose { print!("adds"); }
            result = a + b;
            inputs[ addr_res as usize ] = result;
            addr += 4;
            if verbose { println!("\t{} + {} = {}", a, b, result); }
        }
        else if  opcode == 2  {
            let (a, b, addr_res) = read_3_params!(inputs, addr, mode_a, mode_b, verbose);
            if verbose { print!("multi"); }
            result = a * b;
            inputs[ addr_res as usize ] = result;
            addr += 4;
            if verbose { println!("\t{} * {} = {}", a, b, result); }
        }
        else if  opcode == 3  {
            write_1_param!(inputs, addr, mode_a, input_val, verbose);
            addr += 2;
            if verbose { println!("input\t{}", input_val); }
        }
        else if  opcode == 4  {
            let a = read_1_param!(inputs, addr, mode_a, verbose);
            output = a;
            addr += 2;
            if verbose { println!("output\t{}", a); }
        }
        else if  opcode == 5  {
            let (a, b) = read_2_params!(inputs, addr, mode_a, mode_b, verbose);
            if a != 0 {
                addr = b as usize;
            } else {
                addr += 3;
            }
            if verbose { println!("jump-if-true\t{}", a); }
        }
        else if  opcode == 6  {
            let (a, b) = read_2_params!(inputs, addr, mode_a, mode_b, verbose);
            if a == 0 {
                addr = b as usize;
            } else {
                addr += 3;
            }
            if verbose { println!("jump-if-false\t{}", a); }
        }
        else if  opcode == 7  {
            let (a, b, addr_res) = read_3_params!(inputs, addr, mode_a, mode_b, verbose);
            if a < b {
                inputs[ addr_res as usize ] = 1;
            } else {
                inputs[ addr_res as usize ] = 0;
            }
            addr += 4;
            if verbose { println!("less than\t{}", a); }
        }
        else if  opcode == 8  {
            let (a, b, addr_res) = read_3_params!(inputs, addr, mode_a, mode_b, verbose);
            if a == b {
                inputs[ addr_res as usize ] = 1;
            } else {
                inputs[ addr_res as usize ] = 0;
            }
            addr += 4;
            if verbose { println!("equals\t{}", a); }
        }
        else {
            unimplemented!();
        }
    }
    if verbose { println!("[99]\tend of program\t{}", output); }
    //println!("{:?}", inputs);
    output
}


pub fn part1(args: Vec<String>) {
    header!("1", args);

    let inputs: Vec<i32>;
    match args[3].as_ref() {
        "test1" => inputs = vec![1101,100,-1,4,0],
        "test2" => inputs = vec![1101,100,-1,5,104,0,99],
        "input" => inputs = vec![3,225,1,225,6,6,1100,1,238,225,104,0,1101,86,8,225,1101,82,69,225,101,36,65,224,1001,224,-106,224,4,224,1002,223,8,223,1001,224,5,224,1,223,224,223,102,52,148,224,101,-1144,224,224,4,224,1002,223,8,223,101,1,224,224,1,224,223,223,1102,70,45,225,1002,143,48,224,1001,224,-1344,224,4,224,102,8,223,223,101,7,224,224,1,223,224,223,1101,69,75,225,1001,18,85,224,1001,224,-154,224,4,224,102,8,223,223,101,2,224,224,1,224,223,223,1101,15,59,225,1102,67,42,224,101,-2814,224,224,4,224,1002,223,8,223,101,3,224,224,1,223,224,223,1101,28,63,225,1101,45,22,225,1101,90,16,225,2,152,92,224,1001,224,-1200,224,4,224,102,8,223,223,101,7,224,224,1,223,224,223,1101,45,28,224,1001,224,-73,224,4,224,1002,223,8,223,101,7,224,224,1,224,223,223,1,14,118,224,101,-67,224,224,4,224,1002,223,8,223,1001,224,2,224,1,223,224,223,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,7,677,677,224,102,2,223,223,1005,224,329,1001,223,1,223,1008,226,226,224,1002,223,2,223,1005,224,344,1001,223,1,223,1107,677,226,224,1002,223,2,223,1006,224,359,1001,223,1,223,107,677,677,224,102,2,223,223,1005,224,374,101,1,223,223,1108,677,226,224,102,2,223,223,1005,224,389,1001,223,1,223,1007,677,677,224,1002,223,2,223,1005,224,404,101,1,223,223,1008,677,226,224,102,2,223,223,1005,224,419,101,1,223,223,1108,226,677,224,102,2,223,223,1006,224,434,1001,223,1,223,8,677,226,224,1002,223,2,223,1005,224,449,101,1,223,223,1008,677,677,224,1002,223,2,223,1006,224,464,1001,223,1,223,1108,226,226,224,1002,223,2,223,1005,224,479,1001,223,1,223,1007,226,677,224,102,2,223,223,1005,224,494,1001,223,1,223,1007,226,226,224,102,2,223,223,1005,224,509,101,1,223,223,107,677,226,224,1002,223,2,223,1006,224,524,1001,223,1,223,108,677,677,224,102,2,223,223,1006,224,539,101,1,223,223,7,677,226,224,102,2,223,223,1006,224,554,1001,223,1,223,1107,226,677,224,102,2,223,223,1005,224,569,101,1,223,223,108,677,226,224,1002,223,2,223,1006,224,584,101,1,223,223,108,226,226,224,102,2,223,223,1006,224,599,1001,223,1,223,1107,226,226,224,102,2,223,223,1006,224,614,1001,223,1,223,8,226,677,224,102,2,223,223,1006,224,629,1001,223,1,223,107,226,226,224,102,2,223,223,1005,224,644,101,1,223,223,8,226,226,224,102,2,223,223,1006,224,659,101,1,223,223,7,226,677,224,102,2,223,223,1005,224,674,101,1,223,223,4,223,99,226],
        _ => help!(args)
    }

    let res = run_program(inputs, 1, true);
    println!("==> res = {}", res);
}

pub fn part2(args: Vec<String>) {
    header!("2", args);

    let inputs: Vec<i32>;
    match args[3].as_ref() {
        "test-eq8-pos" => inputs = vec![3,9,8,9,10,9,4,9,99,-1,8],
        "test-lt8-pos" => inputs = vec![3,9,7,9,10,9,4,9,99,-1,8],
        "test-eq8-im" => inputs = vec![3,3,1108,-1,8,3,4,3,99],
        "test-lt8-im" => inputs = vec![3,3,1107,-1,8,3,4,3,99],
        "test-zero-pos" => inputs = vec![3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9],
        "test-zero-im" => inputs = vec![3,3,1105,-1,9,1101,0,0,12,4,12,99,1],
        "test" => inputs = vec![3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99],
        "input" => inputs = vec![3,225,1,225,6,6,1100,1,238,225,104,0,1101,86,8,225,1101,82,69,225,101,36,65,224,1001,224,-106,224,4,224,1002,223,8,223,1001,224,5,224,1,223,224,223,102,52,148,224,101,-1144,224,224,4,224,1002,223,8,223,101,1,224,224,1,224,223,223,1102,70,45,225,1002,143,48,224,1001,224,-1344,224,4,224,102,8,223,223,101,7,224,224,1,223,224,223,1101,69,75,225,1001,18,85,224,1001,224,-154,224,4,224,102,8,223,223,101,2,224,224,1,224,223,223,1101,15,59,225,1102,67,42,224,101,-2814,224,224,4,224,1002,223,8,223,101,3,224,224,1,223,224,223,1101,28,63,225,1101,45,22,225,1101,90,16,225,2,152,92,224,1001,224,-1200,224,4,224,102,8,223,223,101,7,224,224,1,223,224,223,1101,45,28,224,1001,224,-73,224,4,224,1002,223,8,223,101,7,224,224,1,224,223,223,1,14,118,224,101,-67,224,224,4,224,1002,223,8,223,1001,224,2,224,1,223,224,223,4,223,99,0,0,0,677,0,0,0,0,0,0,0,0,0,0,0,1105,0,99999,1105,227,247,1105,1,99999,1005,227,99999,1005,0,256,1105,1,99999,1106,227,99999,1106,0,265,1105,1,99999,1006,0,99999,1006,227,274,1105,1,99999,1105,1,280,1105,1,99999,1,225,225,225,1101,294,0,0,105,1,0,1105,1,99999,1106,0,300,1105,1,99999,1,225,225,225,1101,314,0,0,106,0,0,1105,1,99999,7,677,677,224,102,2,223,223,1005,224,329,1001,223,1,223,1008,226,226,224,1002,223,2,223,1005,224,344,1001,223,1,223,1107,677,226,224,1002,223,2,223,1006,224,359,1001,223,1,223,107,677,677,224,102,2,223,223,1005,224,374,101,1,223,223,1108,677,226,224,102,2,223,223,1005,224,389,1001,223,1,223,1007,677,677,224,1002,223,2,223,1005,224,404,101,1,223,223,1008,677,226,224,102,2,223,223,1005,224,419,101,1,223,223,1108,226,677,224,102,2,223,223,1006,224,434,1001,223,1,223,8,677,226,224,1002,223,2,223,1005,224,449,101,1,223,223,1008,677,677,224,1002,223,2,223,1006,224,464,1001,223,1,223,1108,226,226,224,1002,223,2,223,1005,224,479,1001,223,1,223,1007,226,677,224,102,2,223,223,1005,224,494,1001,223,1,223,1007,226,226,224,102,2,223,223,1005,224,509,101,1,223,223,107,677,226,224,1002,223,2,223,1006,224,524,1001,223,1,223,108,677,677,224,102,2,223,223,1006,224,539,101,1,223,223,7,677,226,224,102,2,223,223,1006,224,554,1001,223,1,223,1107,226,677,224,102,2,223,223,1005,224,569,101,1,223,223,108,677,226,224,1002,223,2,223,1006,224,584,101,1,223,223,108,226,226,224,102,2,223,223,1006,224,599,1001,223,1,223,1107,226,226,224,102,2,223,223,1006,224,614,1001,223,1,223,8,226,677,224,102,2,223,223,1006,224,629,1001,223,1,223,107,226,226,224,102,2,223,223,1005,224,644,101,1,223,223,8,226,226,224,102,2,223,223,1006,224,659,101,1,223,223,7,226,677,224,102,2,223,223,1005,224,674,101,1,223,223,4,223,99,226],
        _ => help!(args)
    }

    let res = run_program(inputs, args[4].parse::<i32>().unwrap(), true);
    println!("==> res = {}", res);
}
